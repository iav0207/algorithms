See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Findbugs:     FAILED (6 warnings)
Checkstyle:   PASSED

Correctness:  34/41 tests passed
Memory:       0/1 tests passed
Timing:       36/41 tests passed

Aggregate score: 77.32%
[Compilation: 5%, API: 5%, Findbugs: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
3.5K Feb 24 11:23 BruteCollinearPoints.java
4.2K Feb 24 11:23 FastCollinearPoints.java
4.3K Feb 24 11:23 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac Point.java
*-----------------------------------------------------------

% javac BruteCollinearPoints.java
*-----------------------------------------------------------

% javac FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% findbugs *.class
*-----------------------------------------------------------
M V EI_EXPOSE_REP EI: Returns a reference to the mutable object stored in the instance variable 'segments', which exposes the internal representation of the class 'BruteCollinearPoints'. Instead, create a defensive copy of the object referenced by 'segments' and return the copy.  At BruteCollinearPoints.java:[line 107]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'BruteCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.   At BruteCollinearPoints.java:[line 25]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 125]
M V EI_EXPOSE_REP EI: Returns a reference to the mutable object stored in the instance variable 'segments', which exposes the internal representation of the class 'FastCollinearPoints'. Instead, create a defensive copy of the object referenced by 'segments' and return the copy.  At FastCollinearPoints.java:[line 95]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'FastCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.   At FastCollinearPoints.java:[line 27]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 41]
Warnings generated: 6

================================================================


% checkstyle *.java
*-----------------------------------------------------------

================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
==> passed

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
==> passed

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
  * throw java.lang.NullPointerException if either argument is null
==> passed


Total: 3/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: Points from a file
  * filename = input8.txt
  * filename = equidistant.txt
    - student   solution has 3 non-null entries
    - reference solution has 4 non-null entries
    - 1 missing entry in student solution: (10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)


  * filename = input40.txt
    - student   solution has 3 non-null entries
    - reference solution has 4 non-null entries
    - 1 missing entry in student solution: (1000, 17000) -> (13000, 17000) -> (17000, 17000) -> (29000, 17000)


  * filename = input48.txt
    - student   solution has 3 non-null entries
    - reference solution has 6 non-null entries
    - 3 missing entries in student solution, including: (18000, 13000) -> (18000, 23000) -> (18000, 26000) -> (18000, 27000)


==> FAILED

Test 2a: Points from a file with horizontal line segments
  * filename = horizontal5.txt
  * filename = horizontal25.txt
==> passed

Test 2b: Random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
  * 10 random horizontal line segments
  * 15 random horizontal line segments
==> passed

Test 3a: Points from a file with vertical line segments
  * filename = vertical5.txt
  * filename = vertical25.txt
==> passed

Test 3b: Random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
  * 10 random vertical line segments
  * 15 random vertical line segments
==> passed

Test 4a: Points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
==> passed

Test 4b: Random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5: Points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 6: Check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - student   solution has 3 non-null entries
    - reference solution has 4 non-null entries
    - 1 missing entry in student solution: (10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)


  * filename = input40.txt
    - student   solution has 3 non-null entries
    - reference solution has 4 non-null entries
    - 1 missing entry in student solution: (1000, 17000) -> (13000, 17000) -> (17000, 17000) -> (29000, 17000)


  * filename = input48.txt
    - student   solution has 3 non-null entries
    - reference solution has 6 non-null entries
    - 3 missing entries in student solution, including: (18000, 13000) -> (18000, 23000) -> (18000, 26000) -> (18000, 27000)


==> FAILED

Test 7: Check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - student   solution has 3 non-null entries
    - reference solution has 4 non-null entries
    - 1 missing entry in student solution: (10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)


  * filename = input40.txt
    - student   solution has 3 non-null entries
    - reference solution has 4 non-null entries
    - 1 missing entry in student solution: (1000, 17000) -> (13000, 17000) -> (17000, 17000) -> (29000, 17000)


  * filename = input48.txt
    - student   solution has 3 non-null entries
    - reference solution has 6 non-null entries
    - 3 missing entries in student solution, including: (18000, 13000) -> (18000, 23000) -> (18000, 26000) -> (18000, 27000)



It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 8: Random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 9: Random line segments
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 10: Check that data type is immutable by testing whether each method
        returns the same value, regardless of any intervening operations
  * input8.txt
    - failed after 5 operations involving BruteCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.segments()
          mutate points[] array that was passed to constructor
          mutate array returned by last call to segments()
          collinear.segments()
    - failed on trial 1 of 100

  * equidistant.txt
    - failed after 9 operations involving BruteCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          mutate points[] array that was passed to constructor
          collinear.segments()
          mutate points[] array that was passed to constructor
          mutate points[] array that was passed to constructor
          mutate points[] array that was passed to constructor
          mutate array returned by last call to segments()
          mutate points[] array that was passed to constructor
          collinear.segments()
    - failed on trial 1 of 100

==> FAILED

Test 11: Check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 13: Throws exception either if argument to constructor is null
         or if any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
==> passed

Test 14: Check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
    - failed on trial 1 of 100
    - does not throw a java.lang.IllegalArgumentException
     5
     24019 15646
     24742 15452
      5104  9507
     25045 30289
     25045 30289

  * 4 points
    - failed on trial 1 of 100
    - does not throw a java.lang.IllegalArgumentException
     4
     20250  7025
      7647 16005
       906 24786
       906 24786

  * 3 points
    - failed on trial 1 of 100
    - does not throw a java.lang.IllegalArgumentException
     3
     27134  8888
     22012 10153
     22012 10153

  * 2 points
    - failed on trial 1 of 100
    - does not throw a java.lang.IllegalArgumentException
     2
     12184 26415
     12184 26415

==> FAILED


Total: 12/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: Points from a file
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = input299.txt
==> passed

Test 2a: Points from a file with horizontal line segments
  * filename = horizontal5.txt
  * filename = horizontal25.txt
  * filename = horizontal50.txt
  * filename = horizontal75.txt
  * filename = horizontal100.txt
==> passed

Test 2b: Random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
  * 10 random horizontal line segments
  * 15 random horizontal line segments
==> passed

Test 3a: Points from a file with vertical line segments
  * filename = vertical5.txt
  * filename = vertical25.txt
  * filename = vertical50.txt
  * filename = vertical75.txt
  * filename = vertical100.txt
==> passed

Test 3b: Random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
  * 10 random vertical line segments
  * 15 random vertical line segments
==> passed

Test 4a: Points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: Random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: Points from a file with 5 or more on some line segments
  * filename = input9.txt
  * filename = input10.txt
  * filename = input20.txt
  * filename = input50.txt
  * filename = input80.txt
  * filename = input300.txt
  * filename = inarow.txt
==> passed

Test 5b: Points from a file with 5 or more on some line segments
  * filename = kw1260.txt
  * filename = rs1423.txt
==> passed

Test 6: Points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 7: Check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = input299.txt
==> passed

Test 8: Check for fragile dependence on return value of toString()
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 9: Random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
  * 25 random line segments
  * 50 random line segments
  * 100 random line segments
==> passed

Test 10: Random line segments
  *  1 random line segment
  *  5 random line segments
  * 25 random line segments
  * 50 random line segments
  * 100 random line segments
==> passed

Test 11: Random distinct points in a given range
  * 5 random points in a 10-by-10 grid
  * 10 random points in a 10-by-10 grid
  * 50 random points in a 10-by-10 grid
  * 90 random points in a 10-by-10 grid
  * 200 random points in a 50-by-50 grid
==> passed

Test 12: M*N points on an M-by-N grid
  * 3-by-3 grid
  * 4-by-4 grid
  * 5-by-5 grid
  * 10-by-10 grid
  * 20-by-20 grid
  * 5-by-4 grid
  * 6-by-4 grid
  * 10-by-4 grid
  * 15-by-4 grid
  * 25-by-4 grid
==> passed

Test 13: Check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
    - failed after 9 operations involving FastCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          FastCollinearPoints collinear = new FastCollinearPoints(points);
          collinear.numberOfSegments() -> 2
          mutate points[] array that was passed to constructor
          collinear.segments()
          collinear.segments()
          collinear.segments()
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          collinear.segments()
    - failed on trial 1 of 100

  * equidistant.txt
    - failed after 11 operations involving FastCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          FastCollinearPoints collinear = new FastCollinearPoints(points);
          collinear.numberOfSegments() -> 4
          collinear.segments()
          collinear.segments()
          collinear.numberOfSegments() -> 4
          mutate array returned by last call to segments()
          mutate points[] array that was passed to constructor
          collinear.numberOfSegments() -> 4
          collinear.numberOfSegments() -> 4
          mutate points[] array that was passed to constructor
          collinear.segments()
    - failed on trial 1 of 100

==> FAILED

Test 14: Check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 15: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 16: Throws exception either if argument to constructor is null
         or if any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
==> passed

Test 17: Check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
    - failed on trial 1 of 100
    - does not throw a java.lang.IllegalArgumentException
     3
      4099 14210
      4099 14210
     25041  3328

  * 2 points
    - failed on trial 1 of 100
    - does not throw a java.lang.IllegalArgumentException
     2
     14566 28372
     14566 28372

==> FAILED


Total: 19/21 tests passed!


================================================================
********************************************************************************
*  MEMORY
********************************************************************************

Computing memory of Point
*-----------------------------------------------------------
Running 1 total tests.

The maximum amount of memory per Point object is 32 bytes.

Student memory = 56 bytes (failed)

Total: 0/1 tests passed!

================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing BruteCollinearPoints
*-----------------------------------------------------------
Running 10 total tests.

Test 1a-1e: Find collinear points among n random distinct points


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    16   0.01        2366           0           2366                    0
=> passed    32   0.01       40890           0          40890                    0
=> passed    64   0.02      676978           0         676978                    0
=> passed   128   0.11    11009250           0       11009250                    0
=> passed   256   2.04   177555906           0      177555906                    0
==> 5/5 tests passed

Test 2a-2e: Find collinear points among n/4 arbitrary line segments


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    16   0.00        1472           0           1472                   32
=> passed    32   0.00       26043           0          26043                   64
=> passed    64   0.02      506363           0         506363                  128
=> passed   128   0.11     7796407           0        7796407                  256
=> passed   256   1.50   127740422           0      127740422                  512
==> 5/5 tests passed

Total: 10/10 tests passed!


================================================================



Timing FastCollinearPoints
*-----------------------------------------------------------
Running 31 total tests.

Test 1a-1g: Find collinear points among n random distinct points


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.02        7808       18548          44904                    0
=> passed   128   0.01       32000       88012         208024                    0
=> passed   256   0.02      129536      413503         956542                    0
=> passed   512   0.18      521216     1895145        4311506                    0
=> passed  1024   0.37     2091008     8519488       19129984                    0
=> passed  2048   0.93     8376320    37889565       84155450                    0
==> 6/6 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (84155450 / 19129984) = 2.14
=> passed

==> 7/7 tests passed

Test 2a-2g: Find collinear points among the n points on an n-by-1 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.01        8320        4764          17848                19400
=> passed   128   0.01       33024       17796          68616                93353
=> FAILED   256   0.02      131584       68717         269018               446471   (1.1x)
=> FAILED   512   0.06      525312      269399        1064110              2049748   (1.4x)
=> FAILED  1024   0.22     2099200     1065026        4229252              9246366   (1.7x)
=> FAILED  2048   0.89     8392704     4231214       16855132             41207557   (1.9x)
=> FAILED  4096   3.12    33562624    16859163       67280950            182093351   (2.1x)
==> 2/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (67280950 / 16855132) = 2.00
=> passed

==> 3/8 tests passed

Test 3a-3g: Find collinear points among the n points on an n/4-by-4 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00       15396       17513          50422                 6371
=> passed   128   0.01       68342       72260         212862                32473
=> passed   256   0.02      300048      284231         868510               160856
=> passed   512   0.07     1327056     1115739        3558534               783913
=> passed  1024   0.24     5815272     4400014       14615300              3720242
=> passed  2048   1.04    25425318    17548830       60522978             17302974
=> passed  4096   4.97   109530544    70000014      249530572             78599717
==> 7/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (249530572 / 60522978) = 2.04
=> passed

==> 8/8 tests passed

Test 4a-4g: Find collinear points among the n points on an n/8-by-8 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00       14878       18408          51694                 5317
=> passed   128   0.00       64834       86550         237934                24067
=> passed   256   0.02      286354      384835        1056024               112561
=> passed   512   0.07     1258012     1623687        4505386               524194
=> passed  1024   0.30     5562132     6735967       19034066              2427857
=> passed  2048   1.36    24040652    27717691       79476034             10987646
=> passed  4096   6.98   103857242   112925944      329709130             49253571
==> 7/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (329709130 / 79476034) = 2.05
=> passed

==> 8/8 tests passed

Total: 26/31 tests passed!


================================================================

